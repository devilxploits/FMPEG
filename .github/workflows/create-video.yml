name: üé¨ Create Video

on:
  repository_dispatch:
    types: [create_video]

jobs:
  create-video:
    runs-on: ubuntu-latest

    container:
      image: docker.io/cashewin/video-tools:latest
      credentials:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
      options: --user 0

    defaults:
      run:
        shell: bash

    steps:
      - name: üßæ Checkout repository
        uses: actions/checkout@v4

      - name: üì¶ Prepare assets from payload
        run: |
          set -euo pipefail
          mkdir -p assets output /tmp

          echo "================================================"
          echo "üé¨ VIDEO CREATION STARTING (Docker Mode)"
          echo "================================================"

          echo '${{ toJson(github.event.client_payload.images) }}' > /tmp/images.json

          idx=0
          while IFS= read -r image_url; do
            if [ -n "$image_url" ] && [ "$image_url" != "null" ]; then
              outfile="assets/image_$(printf '%03d' "$idx").png"
              echo "üì• Downloading image $((idx + 1)): $image_url"
              curl -L --fail --retry 3 -o "$outfile" "$image_url"
              idx=$((idx + 1))
            fi
          done < <(jq -r '.[]?' /tmp/images.json)

          echo "üìä Total images: $idx"
          ls -lh assets/

          if [ -n "${{ github.event.client_payload.voiceover_url || '' }}" ]; then
            echo "üé§ Downloading voiceover..."
            curl -L -o assets/voiceover.mp3 "${{ github.event.client_payload.voiceover_url }}"
          fi

          if [ -n "${{ github.event.client_payload.background_music_url || '' }}" ]; then
            echo "üéµ Downloading background music..."
            curl -L -o assets/bgmusic.mp3 "${{ github.event.client_payload.background_music_url }}"
          fi

          if [ -n "${{ github.event.client_payload.subtitles || '' }}" ]; then
            echo '${{ github.event.client_payload.subtitles }}' > /tmp/subtitles.json
          fi

      - name: üéûÔ∏è Create video with FFmpeg
        run: |
          set -euo pipefail
          mkdir -p fixed
          
          # Fix image dimensions to 1080x1080
          for img in assets/image_*.png; do
            ffmpeg -y -i "$img" -vf "scale=1080:1080:force_original_aspect_ratio=decrease,pad=1080:1080:(ow-iw)/2:(oh-ih)/2" "fixed/$(basename "$img")"
          done

          cd fixed
          IMG_COUNT=$(ls -1 image_*.png | wc -l)
          TOTAL_DURATION=$((IMG_COUNT * 5))
          echo "üïí Total duration = $TOTAL_DURATION seconds"

          # Create concat text file for FFmpeg
          > ../output/input.txt
          for img in image_*.png; do
            echo "file '$PWD/$img'" >> ../output/input.txt
            echo "duration 5" >> ../output/input.txt
          done
          echo "file '$PWD/$(ls -1 image_*.png | tail -1)'" >> ../output/input.txt

          cd ../output
          echo "üé¨ Creating video slideshow..."
          ffmpeg -y -f concat -safe 0 -i input.txt -vsync vfr -pix_fmt yuv420p temp.mp4

          # Generate subtitles file (if payload includes them)
          if [ -f /tmp/subtitles.json ]; then
            echo "üìù Generating professional movie-quality subtitles..."
            > subs.srt
            i=1
            jq -r '.[]' /tmp/subtitles.json | while IFS= read -r line; do
              START=$(( (i - 1) * 5 ))
              END=$(( i * 5 ))
              printf "%d\n%02d:%02d:00,000 --> %02d:%02d:00,000\n%s\n\n" \
                "$i" $((START/60)) $((START%60)) $((END/60)) $((END%60)) "$line" >> subs.srt
              i=$((i + 1))
            done
            
            # Apply movie-quality subtitle styling
            # FontName=Arial Bold - Professional font
            # Fontsize=22 - Small, readable size (not too big)
            # PrimaryColour=&HFFFFFF& - White text
            # OutlineColour=&H000000& - Black outline
            # BackColour=&H80000000& - Semi-transparent black background
            # BorderStyle=3 - Opaque box background style
            # Outline=1.5 - Thin outline for crisp text
            # Shadow=1.5 - Subtle shadow for depth
            # Alignment=2 - Bottom center alignment
            # MarginV=60 - 60 pixels from bottom (doesn't cover video)
            ffmpeg -y -i temp.mp4 \
              -vf "subtitles=subs.srt:force_style='FontName=Arial Bold,Fontsize=22,PrimaryColour=&HFFFFFF&,OutlineColour=&H000000&,BackColour=&H80000000&,BorderStyle=3,Outline=1.5,Shadow=1.5,Alignment=2,MarginV=60'" \
              -c:a copy temp_subs.mp4
            mv temp_subs.mp4 temp.mp4
            echo "‚úÖ Movie-quality subtitles applied"
          fi

          # Add voiceover
          if [ -f ../assets/voiceover.mp3 ]; then
            echo "üé§ Adding voiceover..."
            ffmpeg -y -i temp.mp4 -i ../assets/voiceover.mp3 -c:v copy -c:a aac -shortest temp_vo.mp4
            mv temp_vo.mp4 temp.mp4
          fi

          # Add background music
          if [ -f ../assets/bgmusic.mp3 ]; then
            echo "üéµ Adding background music..."
            HAS_AUDIO=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 temp.mp4 2>/dev/null | wc -l)
            
            if [ -f ../assets/voiceover.mp3 ] && [ $HAS_AUDIO -gt 0 ]; then
              # Mix: 80% voiceover + 20% background music
              ffmpeg -y -i temp.mp4 -i ../assets/bgmusic.mp3 \
                -filter_complex "[1:a]volume=0.2[bg];[0:a][bg]amix=inputs=2:duration=first:dropout_transition=2[a]" \
                -map 0:v -map "[a]" -c:v copy -c:a aac -b:a 192k \
                -movflags +faststart \
                temp_music.mp4
            else
              # Just add background music at 40%
              ffmpeg -y -i temp.mp4 -i ../assets/bgmusic.mp3 \
                -filter_complex "[1:a]volume=0.4[a]" \
                -map 0:v -map "[a]" -c:v copy -c:a aac -shortest \
                -movflags +faststart \
                temp_music.mp4
            fi
            
            if [ -f temp_music.mp4 ] && [ -s temp_music.mp4 ]; then
              mv temp_music.mp4 temp.mp4
              echo "‚úÖ Background music added"
            fi
          fi

          # Final output with optimization
          OUTPUT_NAME=${{ github.event.client_payload.output_name || 'output.mp4' }}
          ffmpeg -y -i temp.mp4 \
            -c:v libx264 -preset medium -crf 23 \
            -c:a aac -b:a 192k \
            -movflags +faststart \
            "$OUTPUT_NAME"

          echo "‚úÖ Final video ready!"
          ls -lh "$OUTPUT_NAME"

      # ============================================
      # üö® CRITICAL: Webhook Upload Step
      # ============================================
      - name: üì§ Upload video to backend via webhook
        if: success() && github.event.client_payload.callback_url != '' && github.event.client_payload.callback_url != null
        run: |
          echo "================================================"
          echo "üì§ UPLOADING VIDEO TO BACKEND"
          echo "================================================"
          
          OUTPUT_NAME=${{ github.event.client_payload.output_name || 'output.mp4' }}
          VIDEO_FILE="output/$OUTPUT_NAME"
          CALLBACK_URL="${{ github.event.client_payload.callback_url }}"
          JOB_ID="${{ github.event.client_payload.job_id }}"
          
          if [ ! -f "$VIDEO_FILE" ]; then
            echo "‚ùå Video file not found: $VIDEO_FILE"
            exit 1
          fi
          
          VIDEO_SIZE=$(wc -c < "$VIDEO_FILE")
          VIDEO_SIZE_MB=$(echo "scale=2; $VIDEO_SIZE / 1024 / 1024" | bc)
          
          echo "üì¶ File: $VIDEO_FILE"
          echo "üìä Size: ${VIDEO_SIZE_MB} MB"
          echo "üîó Webhook URL: $CALLBACK_URL"
          echo "üÜî Job ID: $JOB_ID"
          echo "üîê Run ID: ${{ github.run_id }}"
          echo ""
          
          echo "üì° Uploading video with multipart/form-data..."
          
          RESPONSE=$(curl -X POST "$CALLBACK_URL" \
            -F "video=@$VIDEO_FILE" \
            -F "status=success" \
            -F "run_id=${{ github.run_id }}" \
            -F "job_id=$JOB_ID" \
            -F "webhook_secret=${{ secrets.WEBHOOK_SECRET }}" \
            --max-time 120 \
            --retry 3 \
            --retry-delay 5 \
            -w "\nüìä HTTP Status: %{http_code}\n" \
            -s)
          
          echo "$RESPONSE"
          
          # Check if upload was successful
          if echo "$RESPONSE" | grep -q '"message":"Webhook processed successfully"'; then
            echo "‚úÖ Video uploaded successfully!"
          else
            echo "‚ö†Ô∏è Upload completed but response was unexpected"
            echo "Response: $RESPONSE"
          fi

      # ============================================
      # üì¶ Backup Artifact (7-day retention)
      # ============================================
      - name: üì¶ Upload as backup artifact
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: final_video_${{ github.event.client_payload.job_id }}
          path: output/*.mp4
          retention-days: 7
          compression-level: 0

      # ============================================
      # üîî Failure Notification
      # ============================================
      - name: üîî Send failure notification
        if: failure() && github.event.client_payload.callback_url != '' && github.event.client_payload.callback_url != null
        run: |
          echo "================================================"
          echo "‚ùå VIDEO GENERATION FAILED - SENDING NOTIFICATION"
          echo "================================================"
          
          CALLBACK_URL="${{ github.event.client_payload.callback_url }}"
          JOB_ID="${{ github.event.client_payload.job_id }}"
          
          echo "üì° Sending failure webhook to: $CALLBACK_URL"
          
          curl -X POST "$CALLBACK_URL" \
            -F "status=failed" \
            -F "run_id=${{ github.run_id }}" \
            -F "job_id=$JOB_ID" \
            -F "error=Video generation workflow failed" \
            -F "webhook_secret=${{ secrets.WEBHOOK_SECRET }}" \
            --max-time 30 \
            --retry 3 \
            --retry-delay 3 \
            -w "\nüìä HTTP Status: %{http_code}\n" \
            -s || echo "‚ö†Ô∏è Failed to send failure notification"
