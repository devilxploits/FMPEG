name: üé¨ Create Video

on:
  repository_dispatch:
    types: [create_video]

jobs:
  create-video:
    runs-on: ubuntu-latest

    container:
      image: docker.io/cashewin/video-tools:latest
      credentials:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
      options: --user 0

    defaults:
      run:
        shell: bash

    steps:
      - name: üßæ Checkout repository
        uses: actions/checkout@v4

      - name: üì¶ Prepare assets from payload
        run: |
          set -euo pipefail
          mkdir -p assets output /tmp

          echo "================================================"
          echo "üé¨ VIDEO CREATION STARTING (9:16 Vertical)"
          echo "================================================"

          echo '${{ toJson(github.event.client_payload.images) }}' > /tmp/images.json

          idx=0
          while IFS= read -r image_url; do
            if [ -n "$image_url" ] && [ "$image_url" != "null" ]; then
              outfile="assets/image_$(printf '%03d' "$idx").png"
              echo "üì• Downloading image $((idx + 1)): $image_url"
              curl -L --fail --retry 3 -o "$outfile" "$image_url"
              idx=$((idx + 1))
            fi
          done < <(jq -r '.[]?' /tmp/images.json)

          echo "üìä Total images: $idx"
          ls -lh assets/

          if [ -n "${{ github.event.client_payload.voiceover_url || '' }}" ]; then
            echo "üé§ Downloading voiceover..."
            curl -L -o assets/voiceover.mp3 "${{ github.event.client_payload.voiceover_url }}"
          fi

          if [ -n "${{ github.event.client_payload.background_music_url || '' }}" ]; then
            echo "üéµ Downloading background music..."
            curl -L -o assets/bgmusic.mp3 "${{ github.event.client_payload.background_music_url }}"
          fi

          # Save subtitle text for later processing
          if [ -n "${{ github.event.client_payload.subtitle_text || '' }}" ]; then
            echo '${{ github.event.client_payload.subtitle_text }}' > /tmp/subtitle_text.txt
          fi

      - name: üéûÔ∏è Create vertical video (9:16) for Instagram Reels / YouTube Shorts
        run: |
          set -euo pipefail
          
          echo "================================================"
          echo "üé• VIDEO CREATION - VERTICAL FORMAT (1080x1920)"
          echo "================================================"
          
          # Get actual voiceover duration for proper video length
          DURATION=30
          if [ -f assets/voiceover.mp3 ]; then
            DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 assets/voiceover.mp3)
            DURATION=$(printf "%.0f" "$DURATION")
            echo "üé§ Detected voiceover duration: ${DURATION}s"
          else
            echo "‚è±Ô∏è  Using default duration: ${DURATION}s"
          fi
          
          # Fix image dimensions to 1080x1920 (9:16 vertical)
          mkdir -p fixed
          for img in assets/image_*.png; do
            if [ -f "$img" ]; then
              # Scale to fit 1080x1920 (cover the entire frame, cropping if needed)
              ffmpeg -y -i "$img" \
                -vf "scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920" \
                "fixed/$(basename "$img")"
            fi
          done

          IMG_COUNT=$(ls -1 fixed/image_*.png 2>/dev/null | wc -l)
          
          if [ "$IMG_COUNT" -eq 0 ]; then
            echo "‚ùå No images found to process!"
            exit 1
          fi
          
          # Calculate per-image duration and transitions
          TRANSITION_DURATION=0.5
          DURATION_PER_IMAGE=$(echo "scale=2; ($DURATION + ($IMG_COUNT - 1) * $TRANSITION_DURATION) / $IMG_COUNT" | bc)
          
          echo "üìä Images: $IMG_COUNT"
          echo "üìê Resolution: 1080x1920 (9:16)"
          echo "‚è±Ô∏è  Total duration: ${DURATION}s"
          echo "üé¨ Duration per image: ${DURATION_PER_IMAGE}s"
          echo "üîÄ Transition: ${TRANSITION_DURATION}s"

          # Build complex filter for smooth transitions and zoom
          FILTER_COMPLEX=""
          
          # First, scale and add zoom effect to each image (vertical format)
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            FILTER_COMPLEX="${FILTER_COMPLEX}[${i}:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,setsar=1,fps=30,zoompan=z='min(zoom+0.0015,1.05)':d=${DURATION_PER_IMAGE}*30:s=1080x1920:fps=30[v${i}];"
          done
          
          # Add crossfade transitions between images
          FILTER_COMPLEX="${FILTER_COMPLEX}[v0]"
          for i in $(seq 1 $((IMG_COUNT - 1))); do
            OFFSET=$(echo "scale=2; $i * ($DURATION_PER_IMAGE - $TRANSITION_DURATION)" | bc)
            FILTER_COMPLEX="${FILTER_COMPLEX}[v${i}]xfade=transition=fade:duration=${TRANSITION_DURATION}:offset=${OFFSET}"
            if [ $i -lt $((IMG_COUNT - 1)) ]; then
              FILTER_COMPLEX="${FILTER_COMPLEX}[vt${i}];[vt${i}]"
            fi
          done
          FILTER_COMPLEX="${FILTER_COMPLEX}[vout]"

          # Build input string with proper paths
          INPUTS=""
          for i in $(seq 0 $((IMG_COUNT - 1))); do
            INPUTS="$INPUTS -i fixed/image_$(printf '%03d' $i).png"
          done

          echo "üé¨ Creating vertical slideshow with smooth transitions and zoom..."
          ffmpeg -y $INPUTS -filter_complex "$FILTER_COMPLEX" -map "[vout]" \
            -c:v libx264 -pix_fmt yuv420p -preset medium -crf 23 \
            -movflags +faststart -t $DURATION \
            output/temp.mp4

          echo "‚úÖ Base vertical video created"

          # Generate subtitles with proper timing if subtitle text is provided
          if [ -f /tmp/subtitle_text.txt ]; then
            echo "üìù Generating movie-quality subtitles with audio sync..."
            SUBTITLE_TEXT=$(cat /tmp/subtitle_text.txt)
            
            # Split text into words for timing calculation
            WORD_COUNT=$(echo "$SUBTITLE_TEXT" | wc -w)
            
            if [ "$WORD_COUNT" -gt 0 ]; then
              SECONDS_PER_WORD=$(echo "scale=3; $DURATION / $WORD_COUNT" | bc)
              
              echo "üìä Words: $WORD_COUNT | Rate: ${SECONDS_PER_WORD}s/word"
              
              # Generate SRT file with 8 words per subtitle for readability
              > output/subs.srt
              WORDS=($SUBTITLE_TEXT)
              SUBTITLE_NUM=1
              CURRENT_TIME=0
              WORDS_PER_SUBTITLE=8
              
              for ((i=0; i<${#WORDS[@]}; i+=WORDS_PER_SUBTITLE)); do
                # Get chunk of words
                CHUNK="${WORDS[@]:i:WORDS_PER_SUBTITLE}"
                CHUNK_WORD_COUNT=$(echo "$CHUNK" | wc -w)
                
                # Calculate timing
                START_TIME=$CURRENT_TIME
                CHUNK_DURATION=$(echo "scale=3; $CHUNK_WORD_COUNT * $SECONDS_PER_WORD" | bc)
                END_TIME=$(echo "scale=3; $START_TIME + $CHUNK_DURATION" | bc)
                
                # Format times (HH:MM:SS,mmm)
                format_time() {
                  local seconds=$1
                  local h=$(echo "$seconds / 3600" | bc)
                  local m=$(echo "($seconds % 3600) / 60" | bc)
                  local s=$(echo "$seconds % 60" | bc)
                  local int_s=${s%.*}
                  local ms=$(echo "($s - $int_s) * 1000" | bc)
                  printf "%02d:%02d:%02d,%03d" ${h:-0} ${m:-0} ${int_s:-0} ${ms%.*}
                }
                
                # Write SRT entry
                echo "$SUBTITLE_NUM" >> output/subs.srt
                echo "$(format_time $START_TIME) --> $(format_time $END_TIME)" >> output/subs.srt
                echo "$CHUNK" >> output/subs.srt
                echo "" >> output/subs.srt
                
                SUBTITLE_NUM=$((SUBTITLE_NUM + 1))
                CURRENT_TIME=$END_TIME
              done
              
              echo "‚úÖ Subtitle file created with $((SUBTITLE_NUM - 1)) entries"
              
              # Apply movie-quality subtitle styling (optimized for vertical video)
              ffmpeg -y -i output/temp.mp4 \
                -vf "subtitles=output/subs.srt:force_style='FontName=Arial Bold,Fontsize=18,PrimaryColour=&HFFFFFF&,OutlineColour=&H000000&,BackColour=&H80000000&,BorderStyle=3,Outline=2,Shadow=1.5,Bold=1,Alignment=2,MarginV=80'" \
                -c:a copy output/temp_subs.mp4
              mv output/temp_subs.mp4 output/temp.mp4
              echo "‚úÖ Movie-quality subtitles applied"
            fi
          fi

          # Add voiceover - NO -shortest flag to preserve full audio
          if [ -f assets/voiceover.mp3 ]; then
            echo "üé§ Adding voiceover (full duration)..."
            ffmpeg -y -i output/temp.mp4 -i assets/voiceover.mp3 \
              -c:v copy -c:a aac -b:a 192k \
              -movflags +faststart \
              output/temp_vo.mp4
            mv output/temp_vo.mp4 output/temp.mp4
            echo "‚úÖ Voiceover added"
          fi

          # Add background music with proper mixing
          if [ -f assets/bgmusic.mp3 ]; then
            echo "üéµ Adding background music..."
            HAS_AUDIO=$(ffprobe -v error -select_streams a -show_entries stream=codec_type -of csv=p=0 output/temp.mp4 2>/dev/null | wc -l)
            
            if [ $HAS_AUDIO -gt 0 ]; then
              # Mix: 80% voiceover + 20% background music
              ffmpeg -y -i output/temp.mp4 -i assets/bgmusic.mp3 \
                -filter_complex "[1:a]volume=0.2[bg];[0:a][bg]amix=inputs=2:duration=first:dropout_transition=2[a]" \
                -map 0:v -map "[a]" -c:v copy -c:a aac -b:a 192k \
                -movflags +faststart \
                output/temp_music.mp4
            else
              # Just add background music at 40%
              ffmpeg -y -i output/temp.mp4 -i assets/bgmusic.mp3 \
                -filter_complex "[1:a]volume=0.4[a]" \
                -map 0:v -map "[a]" -c:v copy -c:a aac -b:a 192k \
                -movflags +faststart \
                output/temp_music.mp4
            fi
            
            if [ -f output/temp_music.mp4 ] && [ -s output/temp_music.mp4 ]; then
              mv output/temp_music.mp4 output/temp.mp4
              echo "‚úÖ Background music added"
            fi
          fi

          # Final output with optimization
          OUTPUT_NAME=${{ github.event.client_payload.output_name || 'output.mp4' }}
          ffmpeg -y -i output/temp.mp4 \
            -c:v libx264 -preset medium -crf 23 \
            -c:a aac -b:a 192k \
            -movflags +faststart \
            "output/$OUTPUT_NAME"

          echo "================================================"
          echo "‚úÖ VERTICAL VIDEO CREATED SUCCESSFULLY!"
          echo "================================================"
          ls -lh "output/$OUTPUT_NAME"
          
          # Show final video info
          echo ""
          echo "üìä Final Video Info:"
          FINAL_DURATION=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "output/$OUTPUT_NAME")
          echo "‚è±Ô∏è  Duration: ${FINAL_DURATION}s"
          echo "üìê Resolution: 1080x1920 (9:16 vertical)"
          FINAL_SIZE=$(ls -lh "output/$OUTPUT_NAME" | awk '{print $5}')
          echo "üì¶ Size: $FINAL_SIZE"

      - name: üì§ Upload video to backend via webhook
        if: success() && github.event.client_payload.callback_url != '' && github.event.client_payload.callback_url != null
        run: |
          echo "================================================"
          echo "üì§ UPLOADING VIDEO TO BACKEND"
          echo "================================================"
          
          OUTPUT_NAME=${{ github.event.client_payload.output_name || 'output.mp4' }}
          VIDEO_FILE="output/$OUTPUT_NAME"
          CALLBACK_URL="${{ github.event.client_payload.callback_url }}"
          JOB_ID="${{ github.event.client_payload.job_id }}"
          
          if [ ! -f "$VIDEO_FILE" ]; then
            echo "‚ùå Video file not found: $VIDEO_FILE"
            exit 1
          fi
          
          VIDEO_SIZE=$(wc -c < "$VIDEO_FILE")
          VIDEO_SIZE_MB=$(echo "scale=2; $VIDEO_SIZE / 1024 / 1024" | bc)
          
          echo "üì¶ File: $VIDEO_FILE"
          echo "üìä Size: ${VIDEO_SIZE_MB} MB"
          echo "üîó Webhook URL: $CALLBACK_URL"
          echo "üÜî Job ID: $JOB_ID"
          echo "üîê Run ID: ${{ github.run_id }}"
          echo ""
          
          echo "üì° Uploading video with multipart/form-data..."
          
          RESPONSE=$(curl -X POST "$CALLBACK_URL" \
            -F "video=@$VIDEO_FILE" \
            -F "status=success" \
            -F "run_id=${{ github.run_id }}" \
            -F "job_id=$JOB_ID" \
            -F "webhook_secret=${{ secrets.WEBHOOK_SECRET }}" \
            --max-time 120 \
            --retry 3 \
            --retry-delay 5 \
            -w "\nüìä HTTP Status: %{http_code}\n" \
            -s)
          
          echo "$RESPONSE"
          
          # Check if upload was successful
          if echo "$RESPONSE" | grep -q '"message":"Webhook processed successfully"'; then
            echo "‚úÖ Video uploaded successfully!"
          else
            echo "‚ö†Ô∏è  Upload response: $RESPONSE"
            echo "‚ùå Video upload may have failed - check backend logs"
          fi

      - name: üì§ Upload video as artifact (fallback)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: video-output
          path: output/*.mp4
          retention-days: 7
